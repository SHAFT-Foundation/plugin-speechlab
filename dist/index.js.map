{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import {\n  type IAgentRuntime,\n  ModelType,\n  type Plugin,\n  logger,\n  parseBooleanFromText,\n} from \"@elizaos/core\";\nimport axios, { AxiosInstance, AxiosError } from \"axios\";\n\n// API Constants\nconst API_BASE_URL = \"https://translate-api.speechlab.ai\";\n\n// API Client Interfaces\ninterface LoginPayload {\n  email: string;\n  password: string;\n}\n\ninterface LoginResponse {\n  tokens: {\n    accessToken: {\n      jwtToken: string;\n    };\n  };\n}\n\ninterface CreateDubPayload {\n  name: string;\n  sourceLanguage: string;\n  targetLanguage: string;\n  dubAccent: string;\n  unitType: string;\n  mediaFileURI: string;\n  voiceMatchingMode: \"source\" | \"native\";\n  thirdPartyID: string;\n}\n\ninterface CreateDubResponse {\n  projectId: string;\n}\n\ninterface GenerateLinkPayload {\n  projectId: string;\n}\n\ninterface GenerateLinkResponse {\n  link: string;\n}\n\n// Define the structure for the Dub Media Item (OUTPUTS)\nexport interface DubMedia {\n  _id: string;\n  uri: string;\n  category: string;\n  contentTYpe: string;\n  format: string;\n  operationType: string;\n  presignedURL?: string;\n}\n\n// Define the structure for the main Dub object within a Translation\nexport interface DubObject {\n  id?: string;\n  language?: string;\n  voiceMatchingMode?: string;\n  isDubUpdated?: boolean;\n  mergeStatus?: string;\n  lastDubRunType?: string;\n  medias?: DubMedia[];\n}\n\n// Define the structure for a Translation object\nexport interface Translation {\n  id: string;\n  language: string;\n  dub?: DubObject[];\n}\n\n// Define the structure for the Project Details\nexport interface Project {\n  id: string;\n  job: {\n    name: string;\n    sourceLanguage: string;\n    targetLanguage: string;\n    status: string;\n  };\n  translations?: Translation[];\n}\n\n// Update GetProjectsResponse to use the refined Project type\ninterface GetProjectsResponse {\n  results: Array<Project>;\n  totalResults: number;\n}\n\n// Simple in-memory cache for the token\nlet cachedToken: string | null = null;\nlet tokenExpiryTime: number | null = null;\n\n// Create an Axios instance for API calls\nconst apiClient: AxiosInstance = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  timeout: 30000, // 30 second timeout\n});\n\n/**\n * Handles API errors, logging relevant details.\n */\nfunction handleApiError(error: unknown, context: string): void {\n  if (axios.isAxiosError(error)) {\n    const axiosError = error as AxiosError;\n    logger.log(\n      `[ü§ñ SpeechLab] ‚ùå API Error during ${context}: ${axiosError.message}`,\n    );\n    if (axiosError.response) {\n      logger.log(`[ü§ñ SpeechLab] Status: ${axiosError.response.status}`);\n      logger.log(\n        `[ü§ñ SpeechLab] Data: ${JSON.stringify(axiosError.response.data)}`,\n      );\n    } else if (axiosError.request) {\n      logger.log(\"[ü§ñ SpeechLab] No response received:\", axiosError.request);\n    } else {\n      logger.log(\n        \"[ü§ñ SpeechLab] Error setting up request:\",\n        axiosError.message,\n      );\n    }\n  } else {\n    logger.log(`[ü§ñ SpeechLab] ‚ùå Non-Axios error during ${context}:`, error);\n  }\n}\n\n/**\n * Invalidates the cached authentication token.\n */\nfunction invalidateAuthToken(): void {\n  logger.log(\"[ü§ñ SpeechLab] Invalidating cached authentication token.\");\n  cachedToken = null;\n  tokenExpiryTime = null;\n}\n\n/**\n * Authenticates with the SpeechLab API to get a JWT token.\n */\nasync function getAuthToken(\n  email: string,\n  password: string,\n): Promise<string | null> {\n  // Basic check: If we have a token, return it (improve with expiry check later)\n  if (cachedToken) {\n    logger.log(\"[ü§ñ SpeechLab] Using cached authentication token.\");\n    return cachedToken;\n  }\n\n  logger.log(\"[ü§ñ SpeechLab] No cached token. Authenticating with API...\");\n  const loginPayload: LoginPayload = { email, password };\n\n  try {\n    const response = await apiClient.post<LoginResponse>(\n      \"/v1/auth/login\",\n      loginPayload,\n    );\n    const token = response.data?.tokens?.accessToken?.jwtToken;\n\n    if (token) {\n      logger.log(\n        \"[ü§ñ SpeechLab] ‚úÖ Successfully authenticated and obtained token.\",\n      );\n      cachedToken = token;\n      return token;\n    } else {\n      logger.log(\n        \"[ü§ñ SpeechLab] ‚ùå Authentication successful but token not found in response.\",\n      );\n      return null;\n    }\n  } catch (error) {\n    handleApiError(error, \"authentication\");\n    return null;\n  }\n}\n\n/**\n * Creates a dubbing project in SpeechLab. Handles 401 errors by retrying once after refreshing the token.\n */\nasync function createDubbingProject(\n  email: string,\n  password: string,\n  publicAudioUrl: string,\n  projectName: string,\n  targetLanguageCode: string,\n  thirdPartyId: string,\n  sourceLanguageCode: string = \"en\",\n): Promise<string | null> {\n  logger.log(\n    `[ü§ñ SpeechLab] Attempting to create dubbing project: Name=\"${projectName}\", Source=${sourceLanguageCode}, Target=${targetLanguageCode}, 3rdPartyID=${thirdPartyId}`,\n  );\n\n  let attempt = 1;\n  const maxAttempts = 2; // Initial attempt + 1 retry\n\n  // Ensure projectName is reasonably limited\n  const finalProjectName = projectName.substring(0, 100);\n\n  // Map 'es' to 'es_la' for API compatibility\n  const apiTargetLanguage =\n    targetLanguageCode === \"es\" ? \"es_la\" : targetLanguageCode;\n  const apiDubAccent =\n    targetLanguageCode === \"es\" ? \"es_la\" : targetLanguageCode;\n  logger.log(\n    `[ü§ñ SpeechLab] Mapped target language code ${targetLanguageCode} to API targetLanguage: ${apiTargetLanguage}, dubAccent: ${apiDubAccent}`,\n  );\n\n  const payload: CreateDubPayload = {\n    name: finalProjectName,\n    sourceLanguage: sourceLanguageCode,\n    targetLanguage: apiTargetLanguage, // Use mapped code\n    dubAccent: apiDubAccent, // Use mapped code\n    unitType: \"whiteGlove\",\n    mediaFileURI: publicAudioUrl,\n    voiceMatchingMode: \"source\",\n    thirdPartyID: thirdPartyId,\n  };\n\n  logger.log(\n    `[ü§ñ SpeechLab] Create project payload (Attempt ${attempt}): ${JSON.stringify(payload)}`,\n  );\n\n  while (attempt <= maxAttempts) {\n    const token = await getAuthToken(email, password);\n    if (!token) {\n      logger.log(\n        `[ü§ñ SpeechLab] ‚ùå Cannot create project (Attempt ${attempt}): Failed to get authentication token.`,\n      );\n      return null; // Can't proceed without a token\n    }\n\n    try {\n      const response = await apiClient.post<CreateDubResponse>(\n        \"/v1/projects/createProjectAndDub\",\n        payload,\n        {\n          headers: { Authorization: `Bearer ${token}` },\n        },\n      );\n\n      const projectId = response.data?.projectId;\n      if (projectId) {\n        logger.log(\n          `[ü§ñ SpeechLab] ‚úÖ Successfully created project (Attempt ${attempt}). Project ID: ${projectId} (ThirdPartyID: ${thirdPartyId})`,\n        );\n        return projectId;\n      } else {\n        logger.log(\n          `[ü§ñ SpeechLab] ‚ùå Project creation API call successful (Attempt ${attempt}) but projectId not found in response.`,\n        );\n        return null; // API succeeded but didn't return expected data\n      }\n    } catch (error) {\n      const context = `project creation for ${finalProjectName} (3rdPartyID: ${thirdPartyId}) (Attempt ${attempt})`;\n\n      if (\n        axios.isAxiosError(error) &&\n        error.response?.status === 401 &&\n        attempt < maxAttempts\n      ) {\n        logger.log(\n          `[ü§ñ SpeechLab] ‚ö†Ô∏è Received 401 Unauthorized on attempt ${attempt}. Invalidating token and retrying...`,\n        );\n        invalidateAuthToken(); // Invalidate the cached token\n        attempt++;\n        continue; // Go to the next iteration to retry\n      } else {\n        // Handle non-401 errors or failure on the final attempt\n        handleApiError(error, context);\n        return null;\n      }\n    }\n  }\n\n  logger.log(\n    `[ü§ñ SpeechLab] ‚ùå Failed to create project after ${maxAttempts} attempts.`,\n  );\n  return null;\n}\n\n/**\n * Generates a sharing link for a given SpeechLab project.\n */\nasync function generateSharingLink(\n  email: string,\n  password: string,\n  projectId: string,\n): Promise<string | null> {\n  logger.log(\n    `[ü§ñ SpeechLab] Attempting to generate sharing link for project ID: ${projectId}`,\n  );\n\n  let attempt = 1;\n  const maxAttempts = 2; // Initial attempt + 1 retry\n\n  const payload: GenerateLinkPayload = { projectId };\n  logger.log(\n    `[ü§ñ SpeechLab] Generate link payload (Attempt ${attempt}): ${JSON.stringify(payload)}`,\n  );\n\n  while (attempt <= maxAttempts) {\n    const token = await getAuthToken(email, password);\n    if (!token) {\n      logger.log(\n        `[ü§ñ SpeechLab] ‚ùå Cannot generate link (Attempt ${attempt}): Failed to get authentication token.`,\n      );\n      return null;\n    }\n\n    try {\n      const response = await apiClient.post<GenerateLinkResponse>(\n        \"/v1/collaborations/generateSharingLink\",\n        payload,\n        {\n          headers: { Authorization: `Bearer ${token}` },\n        },\n      );\n\n      const link = response.data?.link;\n      if (link) {\n        logger.log(\n          `[ü§ñ SpeechLab] ‚úÖ Successfully generated sharing link (Attempt ${attempt}): ${link}`,\n        );\n        return link;\n      } else {\n        logger.log(\n          `[ü§ñ SpeechLab] ‚ùå Link generation successful (Attempt ${attempt}) but link not found in response.`,\n        );\n        return null;\n      }\n    } catch (error) {\n      const context = `sharing link generation for project ${projectId} (Attempt ${attempt})`;\n\n      if (\n        axios.isAxiosError(error) &&\n        error.response?.status === 401 &&\n        attempt < maxAttempts\n      ) {\n        logger.log(\n          `[ü§ñ SpeechLab] ‚ö†Ô∏è Received 401 Unauthorized on attempt ${attempt} for link generation. Invalidating token and retrying...`,\n        );\n        invalidateAuthToken();\n        attempt++;\n        continue;\n      } else {\n        handleApiError(error, context);\n        return null;\n      }\n    }\n  }\n\n  logger.log(\n    `[ü§ñ SpeechLab] ‚ùå Failed to generate sharing link after ${maxAttempts} attempts.`,\n  );\n  return null;\n}\n\n/**\n * Gets project details by thirdPartyID to check its status.\n */\nasync function getProjectByThirdPartyID(\n  email: string,\n  password: string,\n  thirdPartyID: string,\n): Promise<Project | null> {\n  logger.log(\n    `[ü§ñ SpeechLab] Getting project status for thirdPartyID: ${thirdPartyID}`,\n  );\n\n  let attempt = 1;\n  const maxAttempts = 2; // Initial attempt + 1 retry\n\n  const encodedThirdPartyID = encodeURIComponent(thirdPartyID);\n  const url = `/v1/projects?sortBy=createdAt%3Aasc&limit=10&page=1&expand=true&thirdPartyIDs=${encodedThirdPartyID}`;\n\n  logger.log(\n    `[ü§ñ SpeechLab] üîç Fetching project status from API URL (Attempt ${attempt}): ${API_BASE_URL}${url}`,\n  );\n\n  while (attempt <= maxAttempts) {\n    const token = await getAuthToken(email, password);\n    if (!token) {\n      logger.log(\n        `[ü§ñ SpeechLab] ‚ùå Cannot check project status (Attempt ${attempt}): Failed to get authentication token.`,\n      );\n      return null;\n    }\n\n    try {\n      const response = await apiClient.get<GetProjectsResponse>(url, {\n        headers: { Authorization: `Bearer ${token}` },\n      });\n\n      if (response.data?.results && response.data.results.length > 0) {\n        const project = response.data.results[0];\n        const status = project.job?.status || \"UNKNOWN\";\n\n        logger.log(\n          `[ü§ñ SpeechLab] ‚úÖ (Attempt ${attempt}) Found project with ID: ${project.id} for thirdPartyID: ${thirdPartyID}`,\n        );\n        logger.log(\n          `[ü§ñ SpeechLab] üìä (Attempt ${attempt}) Project status: ${status}`,\n        );\n        logger.log(\n          `[ü§ñ SpeechLab] üìã (Attempt ${attempt}) Project details: Name: \"${project.job?.name || \"Unknown\"}\", Source: ${project.job?.sourceLanguage || \"Unknown\"}, Target: ${project.job?.targetLanguage || \"Unknown\"}`,\n        );\n        logger.log(\n          `[ü§ñ SpeechLab] üîç (Attempt ${attempt}) Found ${project.translations?.[0]?.dub?.[0]?.medias?.length || 0} media objects in first translation's first dub.`,\n        );\n\n        return project; // Success! Return the project details\n      } else {\n        logger.log(\n          `[ü§ñ SpeechLab] ‚ö†Ô∏è (Attempt ${attempt}) No projects found matching thirdPartyID: ${thirdPartyID}`,\n        );\n        if (response.data?.totalResults !== undefined) {\n          logger.log(\n            `[ü§ñ SpeechLab] API reported ${response.data.totalResults} total results for this query (Attempt ${attempt}).`,\n          );\n        }\n        return null; // No project found, but API call succeeded\n      }\n    } catch (error) {\n      const context = `getting project status for thirdPartyID: ${thirdPartyID} (Attempt ${attempt})`;\n\n      if (\n        axios.isAxiosError(error) &&\n        error.response?.status === 401 &&\n        attempt < maxAttempts\n      ) {\n        logger.log(\n          `[ü§ñ SpeechLab] ‚ö†Ô∏è Received 401 Unauthorized on attempt ${attempt} for project status check. Invalidating token and retrying...`,\n        );\n        invalidateAuthToken();\n        attempt++;\n        continue;\n      } else {\n        handleApiError(error, context);\n        return null;\n      }\n    }\n  }\n\n  logger.log(\n    `[ü§ñ SpeechLab] ‚ùå Failed to get project status for ${thirdPartyID} after ${maxAttempts} attempts.`,\n  );\n  return null;\n}\n\n/**\n * Waits for a project to reach COMPLETE status, checking at regular intervals.\n */\nasync function waitForProjectCompletion(\n  email: string,\n  password: string,\n  thirdPartyID: string,\n  maxWaitTimeMs = 60 * 60 * 1000, // 1 hour default\n  checkIntervalMs = 30000, // 30 seconds default\n): Promise<Project | null> {\n  logger.log(`[ü§ñ SpeechLab] Waiting for project completion: ${thirdPartyID}`);\n  logger.log(\n    `[ü§ñ SpeechLab] Maximum wait time: ${maxWaitTimeMs / 1000 / 60} minutes, Check interval: ${checkIntervalMs / 1000} seconds`,\n  );\n\n  const startTime = Date.now();\n  let pollCount = 0;\n  let lastProjectDetails: Project | null = null; // Store last retrieved details\n\n  while (Date.now() - startTime < maxWaitTimeMs) {\n    pollCount++;\n    const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);\n\n    logger.log(\n      `[ü§ñ SpeechLab] üîÑ Poll #${pollCount} - Checking project status (${elapsedSeconds}s elapsed)...`,\n    );\n\n    // Get the full project details\n    const project = await getProjectByThirdPartyID(\n      email,\n      password,\n      thirdPartyID,\n    );\n    lastProjectDetails = project; // Store the latest result\n\n    if (!project) {\n      logger.log(\n        `[ü§ñ SpeechLab] ‚ö†Ô∏è Poll #${pollCount} - Could not retrieve project details, will retry in ${checkIntervalMs / 1000}s...`,\n      );\n    } else if (project.job?.status === \"COMPLETE\") {\n      const elapsedMinutes = ((Date.now() - startTime) / 1000 / 60).toFixed(1);\n      logger.log(\n        `[ü§ñ SpeechLab] ‚úÖ Poll #${pollCount} - Project completed successfully after ${elapsedMinutes} minutes!`,\n      );\n      return project; // Return the full project object on success\n    } else if (project.job?.status === \"FAILED\") {\n      logger.log(\n        `[ü§ñ SpeechLab] ‚ùå Poll #${pollCount} - Project failed to process!`,\n      );\n      return null; // Return null on failure\n    } else {\n      // Calculate progress (simplified)\n      const status = project.job?.status || \"UNKNOWN\";\n      const progressPercent = status === \"PROCESSING\" ? 50 : 0;\n      let remainingTimeEstimate = \"unknown\";\n\n      if (progressPercent > 0) {\n        const elapsedMs = Date.now() - startTime;\n        const estimatedTotalMs = (elapsedMs / progressPercent) * 100;\n        const estimatedRemainingMs = estimatedTotalMs - elapsedMs;\n        const estimatedRemainingMin = Math.ceil(\n          estimatedRemainingMs / 1000 / 60,\n        );\n        remainingTimeEstimate = `~${estimatedRemainingMin} minutes`;\n      }\n\n      logger.log(\n        `[ü§ñ SpeechLab] üïí Poll #${pollCount} - Project status: ${status}, Progress: ${progressPercent}%, Estimated time remaining: ${remainingTimeEstimate}`,\n      );\n      logger.log(\n        `[ü§ñ SpeechLab] ‚è≥ Poll #${pollCount} - Will check again in ${checkIntervalMs / 1000}s...`,\n      );\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, checkIntervalMs));\n  }\n\n  const maxWaitMinutes = (maxWaitTimeMs / 1000 / 60).toFixed(1);\n  logger.log(\n    `[ü§ñ SpeechLab] ‚è∞ Poll #${pollCount} - Maximum wait time of ${maxWaitMinutes} minutes exceeded without project completion.`,\n  );\n  return lastProjectDetails?.job?.status === \"COMPLETE\"\n    ? lastProjectDetails\n    : null; // Return last details only if complete, else null\n}\n\n/**\n * Function to retrieve SpeechLab settings based on runtime and environment variables.\n * @param {IAgentRuntime} runtime - The agent runtime object.\n * @returns {Object} - Object containing various SpeechLab settings.\n */\nfunction getSpeechLabSettings(runtime: IAgentRuntime) {\n  const getSetting = (key: string, fallback = \"\") =>\n    process.env[key] || runtime.getSetting(key) || fallback;\n\n  return {\n    email: getSetting(\"SPEECHLAB_EMAIL\"),\n    password: getSetting(\"SPEECHLAB_PASSWORD\"),\n    sourceLanguage: getSetting(\"SPEECHLAB_SOURCE_LANGUAGE\", \"en\"),\n    unitType: getSetting(\"SPEECHLAB_UNIT_TYPE\", \"whiteGlove\"),\n    voiceMatchingMode: getSetting(\"SPEECHLAB_VOICE_MATCHING_MODE\", \"source\"),\n    maxWaitTimeMinutes: parseInt(\n      getSetting(\"SPEECHLAB_MAX_WAIT_TIME_MINUTES\", \"60\"),\n    ),\n    checkIntervalSeconds: parseInt(\n      getSetting(\"SPEECHLAB_CHECK_INTERVAL_SECONDS\", \"30\"),\n    ),\n    debug: parseBooleanFromText(getSetting(\"SPEECHLAB_DEBUG\", \"false\")),\n  };\n}\n\n/**\n * Represents the SpeechLab plugin.\n * This plugin provides functionality related to SpeechLab API for audio dubbing.\n * @type {Plugin}\n */\nexport const speechLabPlugin: Plugin = {\n  name: \"speechLab\",\n  description: \"SpeechLab dubbing plugin for voice translation\",\n  models: {\n    [\"AUDIO_DUBBING\"]: async (runtime, options) => {\n      const settings = getSpeechLabSettings(runtime);\n      logger.log(\n        `[ü§ñ SpeechLab] Using AUDIO_DUBBING with source language: ${settings.sourceLanguage}`,\n      );\n\n      // Check credentials\n      if (!settings.email || !settings.password) {\n        throw new Error(\n          \"[ü§ñ SpeechLab] Missing required credentials. Please set SPEECHLAB_EMAIL and SPEECHLAB_PASSWORD\",\n        );\n      }\n\n      // Extract options\n      if (!options || typeof options !== \"object\") {\n        throw new Error(\"[ü§ñ SpeechLab] Missing required dubbing options\");\n      }\n\n      const { audioUrl, targetLanguage, projectName } = options as {\n        audioUrl?: string;\n        targetLanguage?: string;\n        projectName?: string;\n      };\n\n      if (!audioUrl) {\n        throw new Error(\"[ü§ñ SpeechLab] Missing required audioUrl parameter\");\n      }\n\n      if (!targetLanguage) {\n        throw new Error(\n          \"[ü§ñ SpeechLab] Missing required targetLanguage parameter\",\n        );\n      }\n\n      const finalProjectName =\n        projectName || `SpeechLab Dub ${new Date().toISOString()}`;\n      const thirdPartyId = `eliza-${Date.now()}-${targetLanguage}`;\n\n      try {\n        // Create the dubbing project\n        const projectId = await createDubbingProject(\n          settings.email,\n          settings.password,\n          audioUrl,\n          finalProjectName,\n          targetLanguage,\n          thirdPartyId,\n          settings.sourceLanguage,\n        );\n\n        if (!projectId) {\n          throw new Error(\"[ü§ñ SpeechLab] Failed to create dubbing project\");\n        }\n\n        logger.log(\n          `[ü§ñ SpeechLab] Successfully created dubbing project with ID: ${projectId}`,\n        );\n\n        // Wait for the project to complete\n        logger.log(\n          `[ü§ñ SpeechLab] Waiting for project to complete (this may take several minutes)...`,\n        );\n        const completedProject = await waitForProjectCompletion(\n          settings.email,\n          settings.password,\n          thirdPartyId,\n          settings.maxWaitTimeMinutes * 60 * 1000,\n          settings.checkIntervalSeconds * 1000,\n        );\n\n        if (!completedProject) {\n          throw new Error(\n            \"[ü§ñ SpeechLab] Project did not complete successfully\",\n          );\n        }\n\n        // Generate a sharing link\n        logger.log(\n          `[ü§ñ SpeechLab] Generating sharing link for completed project...`,\n        );\n        const sharingLink = await generateSharingLink(\n          settings.email,\n          settings.password,\n          projectId,\n        );\n\n        if (!sharingLink) {\n          throw new Error(\"[ü§ñ SpeechLab] Failed to generate sharing link\");\n        }\n\n        // Return the complete dubbing result\n        return {\n          projectId,\n          status: completedProject.job?.status || \"COMPLETE\",\n          targetLanguage,\n          sharingLink,\n          projectDetails: completedProject,\n        };\n      } catch (error) {\n        throw new Error(\n          `[ü§ñ SpeechLab] Failed to complete dubbing: ${error.message || \"Unknown error occurred\"}`,\n        );\n      }\n    },\n  },\n  tests: [\n    {\n      name: \"test speechlab\",\n      tests: [\n        {\n          name: \"SpeechLab API credential validation\",\n          fn: async (runtime: IAgentRuntime) => {\n            const settings = getSpeechLabSettings(runtime);\n            if (!settings.email || !settings.password) {\n              throw new Error(\n                \"Missing credentials: Please provide valid SpeechLab email and password.\",\n              );\n            }\n          },\n        },\n        {\n          name: \"SpeechLab API connection test\",\n          fn: async (runtime: IAgentRuntime) => {\n            try {\n              const settings = getSpeechLabSettings(runtime);\n              if (!settings.email || !settings.password) {\n                throw new Error(\"Missing credentials for connection test\");\n              }\n\n              // Test by checking if there are any existing projects\n              const result = await getProjectByThirdPartyID(\n                settings.email,\n                settings.password,\n                \"connection-test\",\n              );\n\n              // We don't expect to find this project, but we should get a valid API response\n              logger.log(\"[ü§ñ SpeechLab] API connection test successful\");\n            } catch (error) {\n              throw new Error(\n                `Failed to connect to SpeechLab API: ${error.message || \"Unknown error occurred\"}`,\n              );\n            }\n          },\n        },\n      ],\n    },\n  ],\n};\n\nexport default speechLabPlugin;\n"],"mappings":"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","names":[]}